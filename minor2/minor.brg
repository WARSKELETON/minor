%{
/*
 * selecção de instruções com postfix
 */
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include "node.h"
#include "postfix.h"
#include "y.tab.h"
#include "minor.h"
#include "tabid.h"

#ifndef U_
#define U_ "_"
#endif

#define TRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost);

extern FILE *yyout;
static int forlbl[20], repeatlbl[20], stoplbl[20], forcnt; /* for labels */
int lbl;
int eliflbl;
static int pos;
static char* currentfunc;
static char *mklbl(int n) {
	static char buf[20];
	sprintf(buf, "%cL%d", n < 0 ? '.' : '_', n);
	return strcpy(malloc(strlen(buf)+1),buf);
}
static char *mkfunc(char *s) {
	static char buf[80];
	strcpy(buf, "_");
	strcat(buf, s);
	return buf;
}
static void outchars(Node *chars) {
	int first = 1;

	while (LEFT_CHILD(chars) || first) {
		first = 0;
		
		if (RIGHT_CHILD(chars)->info == tSTR) {
			char* s = RIGHT_CHILD(chars)->value.s;
			while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
		}
		if (RIGHT_CHILD(chars)->info == tINT) {
			fprintf(yyout, pfCHAR, RIGHT_CHILD(chars)->value.i);
		}
		
		chars = LEFT_CHILD(chars);
	}
	fprintf(yyout, pfCHAR, 0);
}
static void outstr(char *s) {
  while (*s) fprintf(yyout, pfCHAR, (unsigned char)*s++);
  fprintf(yyout, pfCHAR, 0);
}
static void pfPrint(int info) {
	if (tTYPE(info) == tINT) {
  		fprintf(yyout, pfCALL pfCALL pfTRASH, "_printi", "_println", 4);
	}
	if (tTYPE(info) == tSTR) {
  		fprintf(yyout, pfCALL pfCALL pfTRASH, "_prints", "_println", 4);
	}
}
static void getId(Node* nm) {
	int typ = 2, nmpos = 0;
	if (IDfind(nm->value.s, (void**)IDtest) >= 0) {
		if (nm->info >= tFUNC) {
			fprintf(yyout, pfCALL pfPUSH, mkfunc(nm->value.s));
		}
		else {
			fprintf(yyout, pfADDRV, nm->value.s);
		}
	}
	else {
		typ = IDfind(nm->value.s, (long*)&nmpos);
		fprintf(yyout, pfLOCV, nmpos);
	}
}
static void assignment(Node* nm) {
	int typ = 2, nmpos = 0;
	if (IDfind(nm->value.s, (void**)IDtest) >= 0) {
		fprintf(yyout, pfDUP pfADDRA, nm->value.s);
	}
	else {
		typ = IDfind(nm->value.s, (long*)&nmpos);
		fprintf(yyout, pfDUP pfLOCA, nmpos * (pfWORD/4));
	}
}
static void variable(Node *var) {
	Node* p = var->SUB(0);
	if (RIGHT_CHILD(p) == NIL) {
		fprintf(yyout, pfGLOBL pfBSS pfALIGN pfLABEL, LEFT_CHILD(p)->value.s, pfOBJ, LEFT_CHILD(p)->value.s);
	}
	else {
		if (var->info & tCNST) {
			fprintf(yyout, pfGLOBL pfRODATA pfALIGN pfLABEL, LEFT_CHILD(p)->value.s, pfOBJ, LEFT_CHILD(p)->value.s);
		}
		else {
			fprintf(yyout, pfGLOBL pfDATA pfALIGN pfLABEL, LEFT_CHILD(p)->value.s, pfOBJ, LEFT_CHILD(p)->value.s);
		}
		if (p->info == tINT)
			fprintf(yyout, pfINTEGER, RIGHT_CHILD(p)->value.i);
		if (p->info == tSTR) {
			char *l = mklbl(++lbl);
			fprintf(yyout, pfRODATA pfALIGN pfLABEL, l);
			outchars(RIGHT_CHILD(p));
			fprintf(yyout, pfDATA pfID, l);
		}
	}
}
static void function(char *name, int enter) {
  fprintf(yyout, pfTEXT pfALIGN pfGLOBL pfLABEL pfENTER, mkfunc(name), pfFUNC, mkfunc(name), enter * (pfWORD/4));
}
static void final() {
    fprintf(yyout, pfIMM pfPOP pfLEAVE pfRET pfLEAVE pfRET, 0);
    fprintf(yyout, pfEXTRN pfEXTRN pfEXTRN pfEXTRN, "_prints", "_printi", "_println", "_readi");
}
/* falta const type ftype */
/* expr: expr */
/* println ? 255 truncar */
%}
%term STMT=';' PRINT='!' ALLOC='#' INDEX='[' IDARGS='(' COMMA=','
%term ADD='+' SUB='-' MUL='*' DIV='/' MOD='%' POW='^' EQU='=' LT='<' GT='>'
%term AND='&' OR='|' NOT='~' READ='?'
%include "y.tab.h"
%%
program: PROGRAM(decls, FUNCTION(funcmain, FARGS(NIL, main)))	1 { final(); }
program: MODULE(decls)		1 {}

decls: NIL					1 {}
decls: gdecls 				1 {}

gdecls: DECL(gdecls, decl)	1 {}
gdecls: DECL(NIL, decl)		1 {}

decl: VAR(vardecl)			1 { variable(p); }
decl: FUNCTION(funcname, FARGS(fargs, eqbody))		1 { fprintf(yyout, pfLEAVE pfRET); }

farg: NUMBER(ID, NIL)	1 { IDnew(RIGHT_CHILD(p)->info, LEFT_CHILD(p)->value.s, pos); pos += 4; }
farg: STRING(ID, NIL)	1 {}
farg: ARRAY(ID, INTS(vdim, NIL))	1 {}

fargs: NIL					1 { pos = 0; }
fargs: ARGS(NIL, farg)		1 { pos = 0; }
fargs: ARGS(fargs, farg)	1 {}

funcname: END(ID, INT)	1 { IDpush(); pos = 8; currentfunc = LEFT_CHILD(p)->value.s; }
funcmain: END(ID, INT)	1 { IDpush(); pos = 0; }

fvar: NUMBER(ID, NIL)	1 { IDnew(RIGHT_CHILD(p)->info, LEFT_CHILD(p)->value.s, pos -= 4); }
fvar: STRING(ID, NIL)	1 {}
fvar: ARRAY(ID, INTS(vdim, NIL))	1 {}

fvars: ARGS(NIL, fvar)		1 {}
fvars: ARGS(fvars, fvar)	1 {}

vardecl: NUMBER(ID, eqint)				1 {}
vardecl: STRING(ID, eqstr)				1 {}
vardecl: ARRAY(ID, INTS(vdim, eqvec))	1 {}

vdim: NIL	1 {}
vdim: INT	1 {}

eqint: NIL	1 {}
eqint: INT	1 {}

eqstr: NIL		1 {}
eqstr: eqchars	1 {}

eqchars: CHARS(NIL, eqchar)		1 {}
eqchars: CHARS(eqchars, eqchar)	1 {}

eqchar: INT		1 {}
eqchar: CHAR	1 {}
eqchar: STR		1 {}

chars: CHARS(NIL, char)			1 {}
chars: CHARS(chars, char)	    1 {}

char: INT
char: CHAR
char: STR

eqvec: NIL	1 {}
eqvec: ints	1 {}

ints: INT	1 {}
ints: INTS(ints, INT)	1 {}

eqbody: NIL	1 {}
eqbody: body	1 {}

main: START(mainfvars, instrs)	1 { IDpop(); }

mainfvars: NIL				1 { function("main", 0); }
mainfvars: fvars			1 { function("main", -pos); }

body: START(bodyfvars, STMT(instrs, ret))	1 {}

bodyfvars: NIL				1 { function(currentfunc, 0); }
bodyfvars: fvars			1 { function(currentfunc, -pos); }

ret: RETURN(NIL)	1 { fprintf(yyout, pfLEAVE pfRET); }
ret: RETURN(expr)	1 { fprintf(yyout, pfPOP pfLEAVE pfRET); }
ret: NIL	1 {}

loop: ret		1 {}
loop: REPEAT	1 { p->place = repeatlbl[forcnt]; fprintf(yyout, pfJMP, mklbl(p->place)); }
loop: STOP		1 { p->place = stoplbl[forcnt]; fprintf(yyout, pfJMP, mklbl(p->place)); }

block: STMT(instrs, loop)		1 {}
forblock: STMT(instrs, loop)	1 { p->place = repeatlbl[forcnt]; fprintf(yyout, pfLABEL, mklbl(p->place)); }

instrs: NIL	1 {}
instrs: STMT(instrs, instr)	1 {}

instr: FI(THEN(if, elifs), else)					1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(LEFT_CHILD(p))->place)); }
instr: FOR(UNTIL(init, forcond), STEP(forblock, postexpr))	1 { fprintf(yyout, pfLABEL, mklbl(RIGHT_CHILD(LEFT_CHILD(p))->place)); }
instr: PRINT(expr)									3 { pfPrint(p->info); }
instr: expr											1 { /* TODO */ fprintf(yyout, pfTRASH, pfWORD); }
instr: ALLOC(alloc,lval)							1 { fprintf(yyout, pfSTORE); }
alloc: expr											1 { fprintf(yyout, pfIMM pfMUL pfALLOC pfSP, pfWORD); }

if: IF(cond, block)		1 { p->place = ++lbl; eliflbl = p->place; fprintf(yyout, pfJMP pfLABEL, mklbl(p->place), mklbl(LEFT_CHILD(p)->place)); }
ifelse: IF(cond, block)

init: test				1 { p->place = forlbl[++forcnt] = ++lbl; repeatlbl[forcnt] = ++lbl; fprintf(yyout, pfLABEL, mklbl(p->place)); }
forcond: expr			1 { p->place = stoplbl[forcnt] = ++lbl; fprintf(yyout, pfJNZ, mklbl(p->place)); }
postexpr: test			1 { p->place = forlbl[forcnt--]; fprintf(yyout, pfJMP, mklbl(p->place)); }
cond: expr				1 { p->place = ++lbl; fprintf(yyout, pfJZ, mklbl(p->place)); }

test: expr				1 { /* TODO */ fprintf(yyout, pfTRASH, pfWORD); }

elifs: NIL
elifs: ELIF(elifs, ifelse)	1 { p->place = eliflbl; fprintf(yyout, pfJMP pfLABEL, mklbl(p->place), mklbl(LEFT_CHILD(RIGHT_CHILD(p))->place)); }

else: NIL
else: block

lval: ID				1 { getId(p); }
lval: INDEX(expr, ID)	1 {}
assign: ID
assign: INDEX(expr, ID)

expr: CHARS(NIL, INT)	1 { fprintf(yyout, pfIMM, RIGHT_CHILD(p)->value.i); }
expr: CHARS(NIL, CHAR)	1 { fprintf(yyout, pfIMM, RIGHT_CHILD(p)->value.i); }
expr: CHARS(NIL, STR)	1 { lbl++; fprintf(yyout, pfRODATA pfALIGN pfLABEL, mklbl(lbl)); outstr(RIGHT_CHILD(p)->value.s); fprintf(yyout, pfTEXT pfADDR, mklbl(lbl)); }
expr: chars				1 { lbl++; fprintf(yyout, pfRODATA pfALIGN pfLABEL, mklbl(lbl)); outchars(p); fprintf(yyout, pfTEXT pfADDR, mklbl(lbl)); }
expr: lval
expr: READ				1 { fprintf(yyout, pfCALL pfPUSH, "_readi"); }
expr: ADDR(lval)		1 {}
expr: ADD(expr, expr)	1 { fprintf(yyout, pfADD); }
expr: SUB(expr, expr)	1 { fprintf(yyout, pfSUB); }
expr: MUL(expr, expr)	1 { fprintf(yyout, pfMUL); }
expr: DIV(expr, expr)	1 { fprintf(yyout, pfDIV); }
expr: MOD(expr, expr)	1 { fprintf(yyout, pfMOD); }
expr: POW(expr, expr)	1 {}
expr: EQU(expr, expr)	1 { fprintf(yyout, pfEQ); }
expr: NE(expr, expr)	1 { fprintf(yyout, pfNE); }
expr: GE(expr, expr)	1 { fprintf(yyout, pfGE); }
expr: LE(expr, expr)	1 { fprintf(yyout, pfLE); }
expr: LT(expr, expr)	1 { fprintf(yyout, pfLT); }
expr: GT(expr, expr)	1 { fprintf(yyout, pfGT); }
expr: AND(and,expr)		1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
and: expr				1 { p->place = ++lbl; fprintf(yyout, pfDUP pfJZ pfTRASH, mklbl(p->place), pfWORD); }
expr: OR(or,expr)		1 { fprintf(yyout, pfLABEL, mklbl(LEFT_CHILD(p)->place)); }
or: expr				1 { p->place = ++lbl; fprintf(yyout, pfDUP pfJNZ pfTRASH, mklbl(p->place), pfWORD); }
expr: NOT(expr)			1 { fprintf(yyout, pfIMM pfEQ, 0); }
expr: UMINUS(expr)		1 { fprintf(yyout, pfNEG); }
expr: EQ(expr, assign)	1 { assignment(RIGHT_CHILD(p)); }
expr: IDARGS(ID, exprs)	1 { fprintf(yyout, pfCALL pfTRASH pfPUSH, mkfunc(LEFT_CHILD(p)->value.s), (int)(pfWORD*(RIGHT_CHILD(p)->place))); }

exprs: COMMA(expr, NIL)		1 { p->place = 1; }
exprs: COMMA(expr, exprs)	1 { p->place = ((LEFT_CHILD(p)->place) + (RIGHT_CHILD(p)->place)); }

%%
extern char **yynames;
extern int trace, errors, debugNode;
void evaluate(Node *p) {
	if (errors) return;
	/* if (trace) */ printNode(p, stdout, yynames);
	if (!yyselect(p) && trace) printf("selection successful\n");
}

#ifndef NOTRACE
static void yytrace(NODEPTR_TYPE p, int eruleno, int cost, int bestcost)
{
	int op = OP_LABEL(p);
	YYCONST char *tname = yytermname[op] ? yytermname[op] : "?";
	if (debugNode) fprintf(stderr, "0x%p:%s matched %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
	if (cost >= MAX_COST && bestcost >= MAX_COST) {
		fprintf(stderr, "0x%p:%s NO MATCH %s with cost %d vs. %d\n", p, tname, yystring[eruleno], cost, bestcost);
		printNode(p, stderr, yynames);
	}
}
#endif
	fprintf(yyout, pfCHAR, 0);